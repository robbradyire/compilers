#include <stdio.h>
#include <stdlib.h>

int MAX_INT = 2147483647;
int MIN_INT = -2147483648;
int ERR = -1;
int plus = '+';
int minus = '-';

typedef enum {
    zero,
    one_to_seven,
    eight_nine,
    bB,
    hH,
    hex,
    sign,
    null,
    INPUT_ERR
} InputType;

typedef enum {
    leading_zero,
    got_1_to_7,
    got_8_9,
    got_hex,
    got_b,
    got_h,
    got_sign,
    num_after_sign,
    VALID,
    STATE_ERR
} StateName;

typedef enum {
    no_error,
    overflow,
    invalid_input
} ErrorType;

/* State
 *
 * contains the state number, the base (8, 10 or 16)
 * and the sign (-1 or 1)
 */
typedef struct {
    StateName state_name;
    int base;
    int sign;
    int count;
} State;

/* new_state()
 *
 * Creates and initializes a State
 */
State * new_state()
{
    State * state;
    state = malloc(sizeof(State));
    state->state_name = leading_zero;
    state->base = 10;
    state->sign = 1;
    state->count = 0;
    return state; 
}

/* delete_state(*State)
 *
 * Frees the space allocated for a State
 */
void delete_state(State * state)
{
    free(state);
}

char over[] = "Overflow";
char valid[] = "Valid";

/* char_type(char)
 *
 * returns the type of character(num, hex etc.)
 */
int char_type(char c)
{
    InputType type;
    if (c == 0)
    {
        type = null;
    }
    else if (c == '0')
    {
        type = zero;
    }
    else if (c >= '1' && c <= '7')
    {
        type = one_to_seven;
    }
    else if (c == '8' || c == '9')
    {
        type = eight_nine;
    }
    else if (c == 'b' || c ==  'B')
    {
        type = bB;
    }
    else if ((c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))
    {
        type = hex;
    }
    else if (c == 'h' || c == 'H')
    {
        type = hH;
    }
    else if (c == '+' || c == '-')
    {
        type = sign;
    }
    else
    {
        type = INPUT_ERR;
    }
    return type;
}

/* get_val(char)
 *
 * returns the value of a character
 * '0'-'9' returns 0-9
 * 'a'/'A' - 'f'/'F' returns 10-15
 * '+' and '-' return their own values 
 * anything else returns -1
 */
int get_val(char c)
{
    if (c >= '0' && c <= '9')
    {
        return c - 48;
    }
    else if (c >= 'A' && c <= 'F')
    {
        return c - 55;
    }
    else if (c >= 'a' && c <= 'f')
    {
        return c - 87;
    }
    else if (c == '+' || c == '-')
    {
        return c;
    }
    else
    {
        return ERR;
    } 
}

/* will_overflow(int, int)
 *
 * checks whether two numbers will overflow when multiplied
 * returns: 1 if the result will overflow, 0 otherwise
 */
int will_overflow(int sum, int multiplicand)
{ 
    if (sum > 0 && MAX_INT / sum < multiplicand)
    {
        return 1;
    }
    else if (sum < 0 && MIN_INT / sum < multiplicand)
    {
        return 1;
    }
    return 0;
}

/* sum(string, *State)
 *
 * converts the string to its integer value
 */
char * sum(char *input, State *state)
{
    int total = 0;
    int sign = state->sign;
    int base = state->base;
    int count = state->count;
    int val;

    int i;
    for (i = 0; i < count; i++)
    {
        val = get_val(input[i]);
        if (val != plus || val != minus)
        {
            if (!will_overflow(total, val))
            {
                total = total * base + get_val(input[i]);
                if (i == 0)
                {
                    total = sign * total;
                }
            }    
            else
            {
                return over;
            }
        }
    }
    return valid;
}
